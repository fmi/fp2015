# Седмица 8 - въведение в Haskell.

Запознахме се с езика за функционално програмиране Haskell.
За него са характерни следните факти:

* Статично типизиран е. Функциите имат типова сигнатура, която описва типовете на параметрите и типът на резултата
* Освен, че е статично типизиран, Haskell поддържа type inference - може да предположи типовата сигнатура на нашата функция, като не се налага да пишем такава сигнатура за всяка функция.
* Езикът е "pure functional", където [всяка функция е чиста](http://en.wikipedia.org/wiki/Pure_function) Ако извикаме два пъти една и съща функция с едканви аргументи, трябва да получим един и същ отговор. Функциите в Haskell нямат странични ефекти.
* Lazy evaluation. В Haskell, може да направим следния израз:

```haskell
take 10 [1..]
```

Което ще ни върне първите 10 елемента на списъка от 1 до безкрайност.

Повече за това, може да прочетете тук - http://en.wikipedia.org/wiki/Lazy_evaluation

* Haskell е език, който се компилира. GHCi представлява интерактивен REPL, в който може да зареждаме Haskell-ски файлове, които се компилират, след което може да извикваме функции от тях.

## Основен синтаксис и функции

### Синтаксис на функция

В Haskell, пишем функции, а нашата програма представлява композиция от функции.

Основният синтаксис за функция изглежда така:

```haskell
inc x = x + 1
```

* Нямаме ключова дума за функция - започваме функция с нейното име
* Тялото на функцията се намира след знака за `=`
* Всяка функция връща стойност, представляващ резултатът на изразът в тялото и

В Haskell, може да дефинираме строго типът на нашата функция:

```haskell
inc :: Int -> Int
int x = x + 1
```

В този случай, може да увеличаваме само цели числа.

Ако пробваме следния израз, ще получим грешка, защото `2.0` e `Double`

```haskell
> inc 2.0
<interactive>:4:5:
    No instance for (Fractional Int) arising from the literal `2.0'
    Possible fix: add an instance declaration for (Fractional Int)
    In the first argument of `inc', namely `2.0'
    In the expression: inc 2.0
    In an equation for `it': it = inc 2.0
```

Ако оставим Haskell сам да предположи тъпът на подобна наша функция:

```haskell
dec x = x - 1
```

Ако попитаме с `:t` в GHCi, Haskell ще ни каже, че може да оперира с тази функция в/у по-голямо множество от типове, които попадат в типовия клас `Num`. Това обаче, ще дойде по-късно в играта.

```haskell
> :t dec
dec :: Num a => a -> a
```

Но с такава типова декларация, предположена от самия Haskell, може да смятаме повече неща:

```haskell
> dec 1
0
> dec 2.5
1.5
```

### Pattern Matching

В Haskell имаме възможността да напишем функция, която да има множество дефиниции, като в отделните дефиниции да очакваме конкретна стойност или конкретен вид на нашия аргумент.

Например, функцията, която пресмята factoriel, изглежда така:

```haskell
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

Първата дефиниция е дъното на нашата рекурсия и ще се извика само, когато `n` стане равно на `0`

По подобен начин може да решим и въпросът с n-тото число на Фибоначи:

```haskell
fib 1 = 1
fib 2 = 1
fib n = fib (n - 1) + fib (n - 2)
```

Pattern matching-a ни позволява да правим доста интересни неща, с които ще се занимаваме по-нататък:

Имплементацията на сумата на цифрите на 1 число, с Pattern Matching, би изглеждала така:

```haskell
sumDigits :: Int -> Int
sumDigits 0 = 0
sumDigits n = (mod n 10) + sumDigits (div n 10)
```

### Guards - подобие на cond в Haskell

Когато искаме да направим функция, която трябва да се справи с множество случаи (if-elses) и търсим нещо подобно на `cond` в Scheme, то тогава на помощ идват стражите!

Синтактично те изглеждат като `|` и се пишат след дефиницията на функцията, като трябва да са на 1 табулация (или 4 разстояния от началото на функцията)

Например, функцията, която пресмята абсолютна стойност на x: (Казва се така, защото вече имаме подобна вградена):

```haskell
abs' x
    | x <  0 = (-x)
    | otherwise = x
```

Всеки `|` се проверява, дали първият израз ще върне истина. Ако това не се случи, се продължава към следващите стражи до достигане на `otherwise`


Обърнете внимание, че основната функция няма `=`, преди стражите!

Имплементация на сумата на цифрите на едно число би изглеждала така:

```haskell
sumDigits :: Int -> Int
sumDigits n
    | n == 0 = 0
    | otherwise = (mod n 10) + sumDigits (div n 10)
```

### Локални дефиниции чрез where

Както в Scheme можехме да дефинираме функции в нашите функции и те да бъдат скрити от глобалния scope, така в Haskell имаме специален `where` синтаксис за локални дефиниции

Например, следната функция изчислява колко храна ще ни трябва за една седмица, в зоопарк с N на брой панди, като знаем, че всяка панда яде по 10 бамбука и 2 чувала с ориз на ден на ден:

```haskell
foodForPandas :: Int -> Int -> Int
foodForPandas timeSpan pandaCount = totalFood
    where
        bambooPerDayPerPanda = 10
        ricePerDayPerPanda = 2
        bambooCount = bambooPerDayPerPanda * pandaCount * timeSpan
        riceCount = ricePerDayPerPanda * pandaCount * timeSpan
        totalFood = bambooCount + riceCount
```

Т.е ако имаме 7 дена и 10 панди, ще ни трябват около 840 единици с храна.

Синтаксисът изисква дефинициите след `where` да са на 1 табулация от горния ред.

За да използваме вече дефинирано име в друга дефиниция, то тази друга дефиниция трябва да се намира под вече дефинираното име.

Други два примера са функциите за проверка на просто число и намиране на лице на триъгълник по формула на Херон:

```haskell
isPrime :: Int -> Bool
isPrime n
    | n <= 1 = False
    | otherwise = isPrime' 2 n
        where
            isPrime' current n
                | current == n = True
                | mod n current == 0 = False
                | otherwise = isPrime' (current + 1) n
```

```haskell
area :: Double -> Double -> Double -> Double
area a b c = sqrt (p * pa * pb * pc)
    where
        p = (a + b + c) / 2
        pa = p - a
        pb = p - b
        pc = p - c
```

## Материали за четене

Прочетете следните глави от Learn You a Haskell:

* http://learnyouahaskell.com/introduction
* http://learnyouahaskell.com/starting-out до списъци

## Настройки за редактор

Тъй като Haskell изисква специфичен синтаксис с табулации, е хубаво да си настроите вашият текстов редактор, така, че да ви помага.

За Sublime, може да сложите следните language preferences, като:

1. Отворите .hs файл и отидете на Preferences
2. Oт там изберете `-> Settings More -> Syntax Specific - User`
3. И сложете следните настройки:

```json
{
        "draw_white_space": "all",
        "tab_size": 4,
        "translate_tabs_to_spaces": true
}
```

Накратко - ще виждате всеки white space и един tab ще бъде 4 space-a.

Освен това, може да си инсталирате следния Plugin - https://github.com/SublimeHaskell/SublimeHaskell
