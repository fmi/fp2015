# Второ упражнение по Haskell

Нещата за които си говорихме:

* Кошници, Типове и Типови класове
* Списъци, функции за списъци и работа със списъци в Haskell

## Кошници, Типове и Типови класове

Тази тема в книгата - http://learnyouahaskell.com/types-and-typeclasses

Haskell е статично типизиран език и всяка функция си има своята сигнатура.

Нека да имаме следната функция:

```haskell
add :: Int -> Int -> Int
add a b = a + b
```

Ако извикаме тази функция с две цели числа, тя ще работи:

```haskell
> add 1 2
3
```

Обаче ако извикаме функцията с `Double` числа, ще получим грешка:

```haskell
> add 1.0 2.0
<interactive>:4:5:
    No instance for (Fractional Int) arising from the literal `1.0'
    Possible fix: add an instance declaration for (Fractional Int)
    In the first argument of `add', namely `1.0'
    In the expression: add 1.0 2.0
    In an equation for `it': it = add 1.0 2.0
```

Какъв е проблемът? Би трябвало да може да съберем както две цели числа, така и две числа с плаваща запетая - не бива това да е проблем.

Проблемът идва от сигнатурата, която ние сами написахме: `add :: Int -> Int -> Int`

Чрез нея се ограничаваме сано с `Int` типове.

Ако махнем сигнатурата и напишем фунцкията само така:

```haskell
add a b = a + b
```

И тестваме в __ghci__:

```haskell
> add 1 2
3
> add 1.0 2.0
3.0
```

Функцията работи!

Haskell се е сетил, че тази функция може да има по-обща сигнатура, така че да нямаме проблем с `Int` и `Double`.

Но как може да разберем тази сигнатура? За щастие, в ghci, има командата `:t`, която ако дадем име на функция, ще върне сигнатурата, която:

* Ние сме написали
* Ако не сме написали сигнатура, ще ни даде сигнатурата, която Haskell сам се е сетил!

Нека да видим нашият `add` как изглежда:

```haskell
> :t add
add :: Num a => a -> a -> a
```

Уау! Нека да видим тази сигнатура отблизо:

```haskell
add :: Num a => a -> a -> a
```

В нея има две нови неща:

* `Num a =>`
* Самото `a`

### Type Variables или функции с a -> a в сигнатурата

В книгата тук - http://learnyouahaskell.com/types-and-typeclasses#type-variables

Когато функцията ни може да работи с всякакъв тип, без да се интересуваме от неговата контретика, може да напишем `a` като име на този тип.

Например, функцията, която намира дължина на списък има следната сигнатура:

```haskell
length :: [a] -> Int
```

Функцията се чете така: __"Length е функция, която приема списък от нещо и връща цяло число".__

Това ни позволява да намерим дължина на списък, без да се интересуваме от какви елементи е съставен този списък!

### Типови класове и Num

В книгата тук - http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101

Ако обаче имаме `Num a =>` в сигнатурата, това означава, че нашият тип `a`, какъвто и да е той, трябва да приднадлежи на типовия клас `Num`.

Тук казваме, че типът трябва да е в кошницата на `Num`.

`Num` е кошница, в която се намират типове като `Int` и `Double` и тази кошница, действа като интерфейс.

Типовете, които се намират в нея, трябва да имплементират функцията `(+)` между две инстанции от дадения тип.

Самият типов клас `Num`, изглежда така в кода на Haskell: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Num.html#Num

### Типови класове за сравняване и нареждане

Ако напишем функцията, която проверява дали елемент се съдържа в списък, тя има следната сигнатура:

```haskell
member :: Eq a => a -> [a] -> Bool
```

Я четем по следния начин:

__member е функция, която взима нещо, списък от това нещо и връща True, ако нещото се съдържа в списъка. Нещото, трябва да приднадлежи на типовия клас `Eq`__

Типовият клас `Eq` дефинира две функции:

* `(==) :: a -> a -> Bool` - проверява дали 2 стойности са равни
* `(/=) :: a -> a -> Bool` - обратната проверка, различно-равно

И по този начин, ние казваме, че нашата функция работи с всички типове, които знаят как да правят `==` !

## Списъци

В книгата тук - http://learnyouahaskell.com/starting-out#an-intro-to-lists

### Функции за списъци

Списъците в Haskell са много сладки:

* Може да създадем списък директно с литерал - `[1, 2, 3, 4]`
* Може да създадем списък с range оператора в Haskell: `[1 .. 10]` - това ще създаде списъка от 1 до 10
* Може да създадем списък с конструктура за списъци - `1 : []` - това ще създаде `[1]`. `1:2:3:4:[]` - ще създаде `[1,2,3,4]`
* Главата на списъка може да вземем с функцията `head`, а опашката с `tail`
* Списък се проверява дали е празен с функцията `null`

### Pattern matching за списъци

В Haskell, имаме много силен Pattern Matching за списъци, който прави животът ни много по-лесен!

Например, нека имаме следния код, написан в ghci:

```haskell
> let (x:xs) = [1,2,3,4]
> x
1
> xs
[2, 3, 4]
```

Може да разбием списък на две части - главата - `x` и опашката - `xs`. По този начин е много удобно да правим рекурсия със списъци, без да се налага да ползваме `head` и `tail`

Нека да си напишем функция, която проверява дали списък е празен:

```haskell
null' :: [a] -> Bool
null' [] = True
null' _ = False
```

На първия ред, pattern match-ваме по празния списък. Тоест - тази дефиниция на функцията ще се изпълни, когато списъкът, подаден като аргумент е празен.

Това ни дава много сила, защото по този начин покрива дъното на много рекурсии, които боравят със списъци.

Двете неща се виждат много добре, в примерната функция, която намира сумата на всички елементи в списък:

```haskell
sum' :: Num a => [a] -> a
sum' [] = 0
sum' (x:xs) = x + sum xs
```

